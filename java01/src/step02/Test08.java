/* 변수 선언: 배열변수와 레퍼런스  */
package step02;

public class Test08 {
  public static void main(String[] args) {
      byte[] arr1 = new byte[3];   
     arr1[0]=10;
     arr1[1] = 20;
     arr1[2] = 30;   
     System.out.printf("%d, %d, %d\n", arr1[0], arr1[1], arr1[2]);
     
     
    arr1 = new byte[] {40,50,60,70,80};
    System.out.printf("%d, %d, %d, %d, %d\n", arr1[0], arr1[1], arr1[2], arr1[3], arr1[4]);
   
    //이전에 만든 배열은?
    //=> 주소를 잃어버렸기 때문에 프로그램이 종료될 때까지 사용할 수 없다.
    //=> 주소를 찾는 방법이 없다.
    //=> 이렇게 주소를 잃어버려 사용할 수 없는 메모리 => 프로그래밍 언어론: "Dangling Object"
    //=> 자바에서는 "쓰레기(Garbage)"라고 함.
    //=> 자바에서는 메모리를 효율적으로 관리하기 위해 
    //=> 이런 쓰레기를 메모리가 부족할 때 마다 정리함.
    //=> 이렇게 쓰레기를 정리해 주는 프로그램을 "쓰레기수집기(Garbage Collector)"
    // Dangling Pointer: 레퍼런스에 저장된 주소가 가리키는 메모리가 정리된 채로 있을 때
    //                            더 이상 그 주소는 유효하지 않음. 이 유효하지 않은 주소를 "Dangling Pointer"
    //=> C/C++ 언어에서는 개발자가 강제로 메모리를 해제시키는 문법이 있다.
    //     그래서 dangling pointer가 가능하다.
    //그러나 Java언어에서는 개발자가 임의로 메모리를 해제시킬 수 없다.
    //그래서 dangling pointer가 불가능하다.
    
    
    //garbage collector => 프로그램을 실행하다보면 가비지가 발생하는데 
    // 그 가비지를 다른 용도로 사용할 수 있게 메모리를 해제시키는 프로그램를 의미
    // <!주의!> 
    // - 가비지가 발생하는 즉시 가비지 컬렉터가 실행되는 것은 아니다!
    //언제 실행? 
    // 1) 메모리 부족
    // - JVM이 프로그램을 실행하다가 메모리가 부족하여 OS에게 새로운 메모리를 달라고 요청하기 전에 실행 
    // 2) JVM이 한가할 때(idle time)
    // - 서버 프로그램인 경우 24시간 365일 내내 실행된다.
    // - 이 경우 JVM이 한가할 때 가비지 컬렉터를 실행한다.
    // - 잠깐 실행하는 일반적인 경우에는 가비지 컬렉터가 실행되지 않는다.    
    // => JVM이 종료되면 JVM이 사용한 모든 메모리는 무조건 OS에 자동 1`반납된다.
  }
}
